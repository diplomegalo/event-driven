# Stateful Streaming

## State Stores and Materializing State from an Event Stream

- **Materializing State** : Une projection des événements d'un stream (immutable).
- **State Store** : Un store qui contient l'état actuel d'une application (mutable).

Les deux notions sont utiles au sein d'un microservice, mais elles sont utilisées à des fins différentes. Le _materializing state_ est utilisé pour lire des données métiers utiles à l'application, tandis que le _state store_ est utilisé pour stocker l'état actuel d'un processus et des données de travail.

L'endroit où stocker le _state store_ peut être soit proche (même container) partageant ainsi le même cycle de vie, soit distant, par exemple accessible au travers d'un réseau et par conséquent avec un cycle de vie différent.

Pour pouvoir choisir, il faut prendre en compte le rôle du _changelog_.

## Recording State to a Changelog Event Stream

En enregistrant les _changelogs_ dans un stream en externe du _data store_ il est possible de reconstruire l'état actuel de l'application à partir de zéro et dans n'importe quel environnement. Cela permet donc de répliquer l'état de l'application sur plusieurs instances.

## Materializing State to an Internal State Store

Un _state store_ interne coexiste avec le microservice dans un même container ou sur une même VM et sont stockés sur un disque local. Chaque instance du microservice a son propre _state store_ associé à une partition du stream. Par conséquent chaque instance peut simplement dropper un state et en reconstruire un autre lors d'une redistribution des partitions et seules les instances qui possèdent la partition ont une copie du state (_consumer group_).

Certains _key-value stores_ sont optimisés pour être utilisés sur des Solid State Drives (SSD) et sont donc très performants et sont donc idéaux pour les _state stores_ internes. Néanmoins, les disques locaux peuvent être des disques réseau, ce qui peut impacter les performances. Ceci est à prendre en considération lors du choix de la solution de _state store_.

### Materializing Global State

Le _global state_ est un cas particulier du _materializing state_ qui au lieu d'être limité à une partition, matérialise toutes les partitions d'un stream ce qui offre une vue complète des données à chaque instance du microservice. Les _global state_ sont utiles pour les microservices qui ont besoin de connaître l'état global de l'application et opportun lorsque les données ne changent pas souvent. Par contre, chaque microservice ayant l'entièreté des données, il est possible de se retrouver avec des données dupliquées, raison pour laquelle il est recommandé d'utiliser cette approche dans le cadre de lectures et de recherches.

### Advantages of Using Internal State

- **Scalability requirements are offloaded from the developer** : Les _state stores_ internes sont instanciés et gérés par l'_event broker_, ce qui laisse le développeur se concentrer sur la logique métier.
- **High-performance disk-based options** : Charger l'état dans la mémoire n'est pas toujours possible, par conséquent une solution de stockage sur disque (SSD) est recommandée pour améliorer les performances des _state stores_ internes.
- **Flexibility to use network-attached disk** : Un disque réseau va augmenter la latence, en outre la parallélisation des opérations d'écriture et de lecture est limitée, car il ne faut pas oublier que les événements sont lus sur base de l'_offset_. Néanmoins, les disques réseau sont une solution qui permet une plus grande flexibilité sur le plan de l'infrastructure (mise à l'échelle, redondance, migration, etc.).

### Disadvantages of Using Internal State

- **Limited to using runtime-defined disk** : Les _state stores_ internes sont liés à la machine virtuelle ou au container, changer la configuration demande que la machine virtuelle ou le container soit stoppé et redémarré.
- **Wasted disk space** : Dans le cas d'un besoin cyclique d'espace disque important, par exemple suivant les piques d'utilisation d'une application de vente entre 10h et 18h, le reste du temps l'espace disque est inutilisé. Par conséquent, réserver un espace disque fixe est une solution qui peut être coûteuse en termes de place perdue.

### Scaling and Recovery of Internal State

Mettre à l'échelle et restauré un _state store_ interne est une tâche identique à celle de la construction d'un _state_. Le processus de construction d'un _state_ doit être terminé avant que le microservice ne commence à traiter les événements. Le moyen le plus rapide et de parcourir le _changelog_ et de reconstruire le _state_ à partir de zéro.

#### Using hot replicas

Les _hot replicas_ sont des copies du _state store_ qui sont prêtes à être utilisées en cas de défaillance. Il est important que chaque replica gère sont propre _offset_ et le synchronise entre les _hot replicas_ et le _state store_ principal de manière à ce que les _hot replicas_ puissent être utilisées immédiatement en cas de défaillance.

Lorsqu'une instance de microservice se coupe et libère une partition, le _partition assignator_ va réassigner la partition à une autre instance et gérer la reconstruction des _hot replicas_ sur base des politiques de réplication définies.

#### Restoring and scaling from changelogs

Lorsqu'une nouvelle instance d'un microservice est crée, celle-ci à un consumer group associé, les partitions sont alors réassignées et le _state store_ est reconstruit à partir du _changelog_. Durant cette phase, le microservice ne traite pas les événements, mais attend que le _state store_ soit prêt de sorte à ne pas introduire de données incohérentes.

#### Restoring and scaling from input event stream

S'il n'existe pas de _changelog_, il est possible de reconstruire le _state store_ à partir du stream d'événements d'entrée (_input event stream_). Ce processus est plus long que de reconstruire le _state store_ à partir du _changelog_.