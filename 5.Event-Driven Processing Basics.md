# Event-Driven Processing Basics

Les trois étapes d'un microservice sont :

1. Recevoir un événement depuis un event stream,
2. Traiter l'événement,
3. Émettre un nouvel événement de sortie, le cas échéant.
4. Faire un _commit offset_ pour marquer l'événement comme traité.

Le traitement de l'événement est le point d'entrée du microservice. A partir de là sont mis en place les mécanismes _data driven_ pour transformer et traiter les données dans le cadre des besoins d'un _bounded context_.

## Composing Stateless Topologies

La topology microservice dans un architecture _event driven_ est essentiellement une suite d'opération qui sont exécutées l'un à la suite de l'autre sur base des événements reçus. Cela consiste à choisir les fonctions de filtrage, de routing, de transformation et d'agrégation pour traiter les événements, comme une chaîne de responsabilité composé d'éléments de traitement implémenté suivant le paradigme de programmation fonctionnelle. Cette vision des choses fait partie du mind set event-driven à intégrer.

### Transformation

La transformation est une opération qui prend un événement en entrée et produit un ou plusieurs autres événements en sortie. Cela peut être un simple changement de format ou une opération plus complexe. Les transformations les plus courantes sont :

- **Filter** : Propagation ou l'inverse de l'événement sur base d'une condition.
- **Map** : Transformation de l'événement en un autre format. Cette transformation peut impacter la clé de l'événement et par conséquent le _repartitioning_ (comprendre la distribution des événements sur les différents _streams_).
- **MapValues** : Transformation des valeurs de l'événement. Cette transformation ne requiert pas de _repartitioning_.
- **Custom transforms** : Application de logique métier plus complexe, des recherches et des communications avec d'autres services de manière synchrone.

Il existe également les opérations : Reduce, Join, Windowing, GroupBy, Split/Select, etc.

### Branching and Merging Streams

Une application consommatrice peut nécessiter de diviser un flux d'événements en plusieurs flux (branching), et dès lors, va consommer un flux d'événements et (re)router les événements vers des flux plus spécifiques sur base de paramètres ou de conditions.

A l'inverse, il est possible de fusionner plusieurs flux d'événements en un seul flux (merging). Cela peut être utile pour combiner des événements de plusieurs sources en un seul flux de manière à être consommé tel quel. Ce cas de figure doit tenir compte de l'ordre des événements.

## Repartitioning Event Streams

Les événements sont distribués sur plusieurs partitions dans une stream. Partitionner une stream permet de distribuer les événements sur plusieurs _brokers_ et de paralléliser le traitement des événements. Les partitions sont identifiées par une clé.

Les événements sont distribués sur les différents _streams_ en fonction de la clé de l'événement et la logique de répartition associé.

Le _repartitioning_ est le fait de produire un nouvel événement avec une des propriétés de l'événement suivantes :

- _Different partition count_ : incrémente le nombre de partitions d'un _stream_ pour augmenter la capacité de traitement parallèle en _downstream_, ou dans le cas de _copartitioning_.
- _Different event key_ : changer la clé de l'événement pour changer la partition sur laquelle l'événement est distribué.
- _Different event partitioner_ : change la logique de répartition des événements.

### Example : Repartitioning an Event Stream

Prenons l'exemple d'événements concernant des utilisateurs, publiés sur un _stream_. Ce stream contient tous les événements des utilisateurs sur une partition. Le _repartitioning_ consiste à redistribuer les événements en créant de nouveaux événements publiés sur des partitions qui sont identifiés sur base de la propriété `userId`. De cette manière, chaque partitions contient les événements d'un utilisateur spécifique et peut être consommé de cette manière. Cette découpe permet d'augmenter le nombre d'instance d'un microservice pour traiter les événements de manière parallèle, où chaque instance de microservice traite les événements d'une partition spécifique. En outre, chacune de ces instances auront en local les données de l'utilisateur concerné, ce qui permet à celles-ci d'opérer le traitement dans un mode _statefull_.
